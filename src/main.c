/*
******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 7.1.0   2019-08-22

The MIT License (MIT)
Copyright (c) 2009-2017 Atollic AB

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

******************************************************************************
*/


/* Includes */
#include <stdint.h>
#include <stdbool.h>
#include "LPC17xx.h"
#include "uart.h"
#include "LT_energymeter.h"
#include "systick_timer.h"

/**
**===========================================================================
**
**  Abstract: main program
**
**===========================================================================
*/

//
// --------------------------------------------------------------------------
//  Gurux Ltd
//
//
//
// Filename:        $HeadURL$
//
// Version:         $Revision$,
//                  $Date$
//                  $Author$
//
// Copyright (c) Gurux Ltd
//
//---------------------------------------------------------------------------
//
//  DESCRIPTION
//
// This file is a part of Gurux Device Framework.
//
// Gurux Device Framework is Open Source software; you can redistribute it
// and/or modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; version 2 of the License.
// Gurux Device Framework is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// This code is licensed under the GNU General Public License v2.
// Full text may be retrieved at http://www.gnu.org/licenses/gpl-2.0.txt
//---------------------------------------------------------------------------

//#include <zephyr.h>
#include <stdio.h>
//#include <uart.h>
#include <string.h>
#include <stdlib.h>
#include "dlms/include/dlmssettings.h"
#include "dlms/include/variant.h"
#include "dlms/include/cosem.h"
#include "dlms/include/server.h"


//typedef enum{false = 0, true = !false} bool;

extern uint32_t SystemCoreClock;

/* Global variables */
extern volatile uint32_t UART3Count;
extern volatile uint8_t UART3Buffer[BUFSIZE];


extern volatile uint32_t UART3Status;
extern volatile uint8_t UART3TxEmpty;

/////////////////////////////////////////////////////////////////////////////
//Serial port settings.
/*#define UART_NAME "UART_0"
static struct device *uart_dev;*/
//static bool frame_rdy;
static int characters;
volatile uint8_t sendReply = 0;

/////////////////////////////////////////////////////////////////////////////
//DLMS settings.
dlmsServerSettings settings;
//Meter serial number.
unsigned long SERIAL_NUMBER = 123456;

#define HDLC_BUFFER_SIZE 128
#define PDU_BUFFER_SIZE 256
static unsigned char pdu[PDU_BUFFER_SIZE];
static unsigned char frame[HDLC_BUFFER_SIZE];
gxByteBuffer reply;
static gxData ldn;
//Don't use clock as a name. Some compilers are using clock as reserved word.
//static gxClock clock1;
static gxAssociationLogicalName association;
static gxRegister activePowerL1;
static gxRegister apparentPowerL1, liPowerFactor, l1InstVoltage, l2InstVoltage, l3InstVoltage,
					l1InstCurrent, l2InstCurrent, l3InstCurrent, lineFreq;
//static long started;

const gxObject* ALL_OBJECTS[] = { &association.base,
								  &ldn.base,
								  &activePowerL1.base,
								  &apparentPowerL1.base,
								  &liPowerFactor.base,
								  &l1InstCurrent.base,
								  &l1InstVoltage.base,
								  &l2InstCurrent.base,
								  &l2InstVoltage.base,
								  &l3InstCurrent.base,
								  &l3InstVoltage.base,
								  //&clock1.base,
								  &lineFreq.base};

long time_current(void)
{
  //Get current time.
  //Because there is no clock, clock object keeps base time and uptime is added to that.
  //return time_toUnixTime(&clock1.time.value) + (_impl_k_uptime_get() - started) / 1000;
	return 0;
}

long time_elapsed(void)
{
  //return _impl_k_uptime_get();
	return 0;
}

void time_now(
gxtime* value)
{
  //long offset = time_current();
  //(_impl_k_uptime_get() - started) / 1000;
  //time_init4(value, offset);
	return;
}

///////////////////////////////////////////////////////////////////////
//This method adds example Logical Name Association object.
///////////////////////////////////////////////////////////////////////
int addAssociation()
{
  const unsigned char ln[6] = { 0, 0, 40, 0, 1, 255 };
  cosem_init2((gxObject*) &association.base, DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME, ln);
  //Only Logical Device Name is add to this Association View.
  //Use this if you  need to save heap.
  oa_attach(&association.objectList, ALL_OBJECTS, sizeof(ALL_OBJECTS) / sizeof(ALL_OBJECTS[0]));
  bb_addString(&association.secret, "Gurux");
  association.authenticationMechanismName.mechanismId = DLMS_AUTHENTICATION_NONE;
  return 0;
}

///////////////////////////////////////////////////////////////////////
//Add Logical Device Name. 123456 is meter serial number.
///////////////////////////////////////////////////////////////////////
// COSEM Logical Device Name is defined as an octet-string of 16 octets.
// The first three octets uniquely identify the manufacturer of the device and it corresponds
// to the manufacturer's identification in IEC 62056-21.
// The following 13 octets are assigned by the manufacturer.
//The manufacturer is responsible for guaranteeing the uniqueness of these octets.
int addLogicalDeviceName() {
  int ret;
  char buff[17];
  sprintf(buff, "GRX%.13lu", SERIAL_NUMBER);
  const unsigned char ln[6] = { 0,0,42,0,0,255 };
  if ((ret = cosem_init2((gxObject*)&ldn.base, DLMS_OBJECT_TYPE_DATA, ln)) != 0)
  {
      return ret;
  }
  var_addBytes(&ldn.value, (unsigned char*)buff, 16);
  return 0;
}

///////////////////////////////////////////////////////////////////////
//This method adds example clock object.
///////////////////////////////////////////////////////////////////////
#if 0
int addClockObject()
{
  int ret;
  //Add default clock. Clock's Logical Name is 0.0.1.0.0.255.
  const unsigned char ln[6] = { 0,0,1,0,0,255 };
  if ((ret = cosem_init2(&clock1.base, DLMS_OBJECT_TYPE_CLOCK, ln)) != 0)
  {
    return ret;
  }
  time_init(&clock1.time, 2019, 1, 1, 0, 0, 0, 0, 0);
  time_init(&clock1.begin, -1, 9, 1, -1, -1, -1, -1, -1);
  time_init(&clock1.end, -1, 3, 1, -1, -1, -1, -1, -1);
  return 0;
}
#endif

///////////////////////////////////////////////////////////////////////
//This method adds example register object.
///////////////////////////////////////////////////////////////////////
int addPfRegisterObject()
{
  int ret;
  const unsigned char ln[6] = { 1,0,13,7,0,255  };
  if ((ret = cosem_init2((gxObject*)&liPowerFactor, DLMS_OBJECT_TYPE_REGISTER, ln)) != 0)
  {
    return ret;
  }
  //10 ^ 0 =  10
//  liPowerFactor.scaler = 0;	//rakesh
  liPowerFactor.scaler = -3;
  liPowerFactor.unit = 0xFF;

  return 0;
}


///////////////////////////////////////////////////////////////////////
//This method adds example register object.
///////////////////////////////////////////////////////////////////////
int addl1VoltageRegisterObject()
{
  int ret;
  const unsigned char ln[6] = { 1,0,32,7,0,255  };
  if ((ret = cosem_init2((gxObject*)&l1InstVoltage, DLMS_OBJECT_TYPE_REGISTER, ln)) != 0)
  {
    return ret;
  }
  //10 ^ 1 =  10
  l1InstVoltage.scaler = -2;
  l1InstVoltage.unit = 35;

  return 0;
}


///////////////////////////////////////////////////////////////////////
//This method adds example register object.
///////////////////////////////////////////////////////////////////////
int addl2VoltageRegisterObject()
{
  int ret;
  const unsigned char ln[6] = { 1,0,52,7,0,255  };
  if ((ret = cosem_init2((gxObject*)&l2InstVoltage, DLMS_OBJECT_TYPE_REGISTER, ln)) != 0)
  {
    return ret;
  }
  //10 ^ 1 =  10
//  l2InstVoltage.scaler = 0;	//rakesh
  l2InstVoltage.scaler = -2;
  l2InstVoltage.unit = 35;

  return 0;
}

///////////////////////////////////////////////////////////////////////
//This method adds example register object.
///////////////////////////////////////////////////////////////////////
int addl3VoltageRegisterObject()
{
  int ret;
  const unsigned char ln[6] = { 1,0,72,7,0,255  };
  if ((ret = cosem_init2((gxObject*)&l3InstVoltage, DLMS_OBJECT_TYPE_REGISTER, ln)) != 0)
  {
    return ret;
  }
  //10 ^ 1 =  10
//  l3InstVoltage.scaler = 0;	//rakesh
  l3InstVoltage.scaler = -2;
  l3InstVoltage.unit = 35;

  return 0;
}


///////////////////////////////////////////////////////////////////////
//This method adds example register object.
///////////////////////////////////////////////////////////////////////
int addl1CurrentRegisterObject()
{
  int ret;
  const unsigned char ln[6] = { 1,0,31,7,0,255  };
  if ((ret = cosem_init2((gxObject*)&l1InstCurrent, DLMS_OBJECT_TYPE_REGISTER, ln)) != 0)
  {
    return ret;
  }
  //10 ^ 1 =  10
//  l1InstCurrent.scaler = 0;	//rakesh
  l1InstCurrent.scaler = -3;
  l1InstCurrent.unit = 33;

  return 0;
}


///////////////////////////////////////////////////////////////////////
//This method adds example register object.
///////////////////////////////////////////////////////////////////////
int addl2CurrentRegisterObject()
{
  int ret;
  const unsigned char ln[6] = { 1,0,51,7,0,255  };
  if ((ret = cosem_init2((gxObject*)&l2InstCurrent, DLMS_OBJECT_TYPE_REGISTER, ln)) != 0)
  {
    return ret;
  }
  //10 ^ 1 =  10
//  l2InstCurrent.scaler = 0;	//rakesh
  l2InstCurrent.scaler = -3;
  l2InstCurrent.unit = 33;

  return 0;
}

///////////////////////////////////////////////////////////////////////
//This method adds example register object.
///////////////////////////////////////////////////////////////////////
int addl3CurrentRegisterObject()
{
  int ret;
  const unsigned char ln[6] = { 1,0,71,7,0,255  };
  if ((ret = cosem_init2((gxObject*)&l3InstCurrent, DLMS_OBJECT_TYPE_REGISTER, ln)) != 0)
  {
    return ret;
  }
  //10 ^ 1 =  10
//  l3InstCurrent.scaler = 0;	//rakesh
  l3InstCurrent.scaler = -3;
  l3InstCurrent.unit = 33;

  return 0;
}

///////////////////////////////////////////////////////////////////////
//This method adds example register object.
///////////////////////////////////////////////////////////////////////
int addKwhRegisterObject()
{
  int ret;
  const unsigned char ln[6] = { 1,0,1,8,0,255  };
  if ((ret = cosem_init2((gxObject*)&activePowerL1, DLMS_OBJECT_TYPE_REGISTER, ln)) != 0)
  {
    return ret;
  }
  //10 ^ 1 =  10
//  activePowerL1.scaler = 0;	//rakesh
  activePowerL1.scaler = -4;
  activePowerL1.unit = 30;
  return 0;
}

///////////////////////////////////////////////////////////////////////
//This method adds example register object.
///////////////////////////////////////////////////////////////////////
int addKvahRegisterObject()
{
  int ret;
  const unsigned char ln[6] = { 1,0,9,8,0,255 };
  if ((ret = cosem_init2((gxObject*)&apparentPowerL1, DLMS_OBJECT_TYPE_REGISTER, ln)) != 0)
  {
    return ret;
  }
  //10 ^ 1 =  10
//  apparentPowerL1.scaler = 0;	//rakesh
  apparentPowerL1.scaler = -4;
  apparentPowerL1.unit = 31;
  return 0;
}

//rekesh
///////////////////////////////////////////////////////////////////////
//This method adds example register object.
///////////////////////////////////////////////////////////////////////
int addlineFreq()
{
  int ret;
  const unsigned char ln[6] = { 1,0,14,7,0,255 };
  if ((ret = cosem_init2((gxObject*)&lineFreq, DLMS_OBJECT_TYPE_REGISTER, ln)) != 0)
  {
    return ret;
  }
  //10 ^ 1 =  10
//  apparentPowerL1.scaler = 0;	//rakesh
  lineFreq.scaler = -2;
  lineFreq.unit = 31;
  return 0;
}



int svr_InitObjects(
  dlmsServerSettings *settings)
{
  addLogicalDeviceName();
  //addClockObject();
  //addRegisterObject();
  addl1VoltageRegisterObject();
  addl1CurrentRegisterObject();
  addl2VoltageRegisterObject();
  addl2CurrentRegisterObject();
  addl3VoltageRegisterObject();
  addl3CurrentRegisterObject();
  addKwhRegisterObject();
  addKvahRegisterObject();
  addPfRegisterObject();
  addAssociation();
  addlineFreq();	//rakesh
  oa_attach(&settings->base.objects, ALL_OBJECTS, sizeof(ALL_OBJECTS) / sizeof(ALL_OBJECTS[0]));
  return 0;
}

int svr_findObject(
  dlmsSettings* settings,
  DLMS_OBJECT_TYPE objectType,
  int sn,
  unsigned char* ln,
  gxValueEventArg *e)
{
  if (objectType == DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME)
  {
    e->target = &association.base;
  }
  return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
void svr_preRead(
dlmsSettings* settings,
  gxValueEventCollection* args)
{
  gxValueEventArg *e;
  int ret, pos;
  DLMS_OBJECT_TYPE type;

  for (pos = 0; pos != args->size; ++pos)
  {
    if ((ret = vec_getByIndex(args, pos, &e)) != 0)
    {
      return;
    }
    //Let framework handle Logical Name read.
    if (e->index == 1)
    {
      continue;
    }

    //Get target type.
    type = (DLMS_OBJECT_TYPE)e->target->objectType;
    //Let Framework will handle Association objects and profile generic automatically.
    if (type == DLMS_OBJECT_TYPE_ASSOCIATION_LOGICAL_NAME ||
    type == DLMS_OBJECT_TYPE_ASSOCIATION_SHORT_NAME)
    {
      continue;
    }
    //Update value by one every time when user reads register.
    else if (e->target == &activePowerL1.base && e->index == 2)
    {
    	//Call modbus kwh function here
//    	activePowerL1.value.dblVal = (double )readTotalActivePower();	//rakesh
    	activePowerL1.value.ulVal = (unsigned long )readTotalActivePower();
        //var_setUInt32(&activePowerL1.value, activePowerL1.value.ulVal + 1);
    	var_setUInt32(&activePowerL1.value, activePowerL1.value.ulVal);	//
    	//var_setDouble(&activePowerL1.value, activePowerL1.value.dblVal);	//rakesh
    }

    else if (e->target == &apparentPowerL1.base && e->index == 2)
    {
    	 //Call modbus kvh function here
//    	  apparentPowerL1.value.dblVal = (double)readTotalApparentPower();	//rakesh
    	  apparentPowerL1.value.ulVal = (unsigned long)readTotalApparentPower();
         //var_setUInt32(&apparentPowerL1.value, apparentPowerL1.value.ulVal + 1);
    	//var_setFloat(&apparentPowerL1.value, apparentPowerL1.value.fltVal);
//    	  var_setDouble(&apparentPowerL1.value, apparentPowerL1.value.dblVal);	//rakesh
    	  var_setUInt32(&apparentPowerL1.value, apparentPowerL1.value.ulVal);
    }
    else if(e->target == &liPowerFactor.base && e->index == 2)
    {
//    	liPowerFactor.value.dblVal = (double) readTotalPowerFactor();	//rakesh
    	liPowerFactor.value.ulVal = (unsigned long) readTotalPowerFactor();
//    	var_setDouble(&liPowerFactor.value, liPowerFactor.value.dblVal);	//rakesh
    	var_setUInt32(&liPowerFactor.value, liPowerFactor.value.ulVal);
    }
    else if (e->target == &l1InstCurrent.base && e->index == 2)
	{
    	 //Call modbus R phase current function here
//    	l1InstCurrent.value.dblVal = (double) readCurrent(CR_REG);	//rakesh
    	l1InstCurrent.value.ulVal = (unsigned long) readCurrent(CR_REG);
		 //var_setUInt32(&l1InstCurrent.value, l1InstCurrent.value.ulVal + 1);
//    	var_setDouble(&l1InstCurrent.value, l1InstCurrent.value.dblVal);	//rakesh
    	var_setUInt32(&l1InstCurrent.value, l1InstCurrent.value.ulVal);
	}
    else if (e->target == &l2InstCurrent.base && e->index == 2)
	{
    	//Call modbus Y phase current function here
//    	l2InstCurrent.value.dblVal = (double) readCurrent(CY_REG);	//rakesh
    	l2InstCurrent.value.ulVal = (unsigned long) readCurrent(CY_REG);
		 //var_setUInt32(&l2InstCurrent.value, l2InstCurrent.value.ulVal + 1);
//    	var_setDouble(&l2InstCurrent.value, l2InstCurrent.value.dblVal);	//rakesh
    	var_setUInt32(&l2InstCurrent.value, l2InstCurrent.value.ulVal);
	}

    else if (e->target == &l3InstCurrent.base && e->index == 2)
	{
    	//Call modbus B phase current function here
//    	l3InstCurrent.value.dblVal = (double) readCurrent(CB_REG);	//rakesh
    	l3InstCurrent.value.ulVal = (unsigned long) readCurrent(CB_REG);
		 //var_setUInt32(&l3InstCurrent.value, l3InstCurrent.value.ulVal + 1);
//    	var_setDouble(&l3InstCurrent.value, l3InstCurrent.value.dblVal);	//rakesh
    	var_setUInt32(&l3InstCurrent.value, l3InstCurrent.value.ulVal);
	}

    else if (e->target == &l1InstVoltage.base && e->index == 2)
	{
    	//Call modbus R phase voltage function here
//    	l1InstVoltage.value.dblVal = (double)readVoltage(VR_REG);	//rakesh
    	l1InstVoltage.value.ulVal = (unsigned long)readVoltage(VR_REG);
		 //var_setUInt32(&l1InstVoltage.value, l1InstVoltage.value.ulVal + 1);
//    	var_setDouble(&l1InstVoltage.value, l1InstVoltage.value.dblVal);	//rakesh
    	var_setUInt32(&l1InstVoltage.value, l1InstVoltage.value.ulVal);
	}

    else if (e->target == &l2InstVoltage.base && e->index == 2)
	{
    	//Call modbus Y phase voltage function here
//    	l2InstVoltage.value.dblVal = (double)readVoltage(VY_REG);	//rakesh
    	l2InstVoltage.value.ulVal = (unsigned long)readVoltage(VY_REG);
		 //var_setUInt32(&l2InstVoltage.value, l2InstVoltage.value.ulVal + 1);
//    	var_setDouble(&l2InstVoltage.value, l2InstVoltage.value.dblVal);	//rakesh
    	var_setUInt32(&l2InstVoltage.value, l2InstVoltage.value.ulVal);
	}

    else if (e->target == &l3InstVoltage.base && e->index == 2)
	{
    	//Call modbus B phase voltage function here
//    	l3InstVoltage.value.dblVal = (double)readVoltage(VB_REG);	//rakesh
    	l3InstVoltage.value.ulVal = (unsigned long)readVoltage(VB_REG);
		 //var_setUInt32(&l3InstVoltage.value, l3InstVoltage.value.ulVal + 1);
//    	var_setDouble(&l3InstVoltage.value, l3InstVoltage.value.dblVal);	//rakesh
    	var_setUInt32(&l3InstVoltage.value, l3InstVoltage.value.ulVal);
	}
    //Get time if user want to read date and time.
#if 0
    else if (e->target == &clock1.base && e->index == 2)
    {
      e->value.dateTime = (gxtime*) malloc(sizeof(gxtime));
      time_now(e->value.dateTime);
      e->value.vt = DLMS_DATA_TYPE_DATETIME;
      e->handled = true;
     // time_now(&((gxClock*)e->target)->time);
    }
#endif
    //line Frequency
    else if (e->target == &lineFreq.base && e->index == 2)
	{
    	//Call modbus B phase voltage function here
//    	l3InstVoltage.value.dblVal = (double)readVoltage(VB_REG);	//rakesh
    	lineFreq.value.ulVal = (unsigned long)readLineFrequency();
		 //var_setUInt32(&l3InstVoltage.value, l3InstVoltage.value.ulVal + 1);
//    	var_setDouble(&l3InstVoltage.value, l3InstVoltage.value.dblVal);	//rakesh
    	var_setUInt32(&lineFreq.value, lineFreq.value.ulVal);
	}
  }
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
void svr_preWrite(
dlmsSettings* settings,
  gxValueEventCollection* args)
{
  gxValueEventArg *e;
  int pos;
  for (pos = 0; pos != args->size; ++pos)
  {
    if (vec_getByIndex(args, pos, &e) != 0)
    {
      break;
    }
#if 0
    //Set new base time if user wants to set date and time.
    if (e->target == &clock1.base && e->index == 2)
    {
      //started = _impl_k_uptime_get();
    }
#endif
  }
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
void svr_preAction(
dlmsSettings* settings,
  gxValueEventCollection* args)
{
#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
  char str[25];
#endif
  gxValueEventArg *e;
  int ret, pos;
  for (pos = 0; pos != args->size; ++pos)
  {
    if ((ret = vec_getByIndex(args, pos, &e)) != 0)
    {
            return;
    }
#if defined(_WIN32) || defined(_WIN64) || defined(__linux__)//If Windows or Linux
    hlp_getLogicalNameToString(e->target->logicalName, str);
    printf("Action %s:%d\n", str, e->index);
#endif
  }
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
void svr_postRead(
dlmsSettings* settings,
  gxValueEventCollection* args)
{
}
/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
void svr_postWrite(
dlmsSettings* settings,
  gxValueEventCollection* args)
{
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
void svr_postAction(
dlmsSettings* settings,
  gxValueEventCollection* args)
{
  gxValueEventArg *e;
  int ret, pos;
  for (pos = 0; pos != args->size; ++pos)
  {
    if ((ret = vec_getByIndex(args, pos, &e)) != 0)
    {
      return;
    }
  }
}

unsigned char svr_isTarget(
	dlmsSettings *settings,
	unsigned long serverAddress,
	unsigned long clientAddress)
{
  //Check server address using serial number.
  if ((serverAddress & 0x3FFF) == SERIAL_NUMBER % 10000 + 1000)
  {
      return 1;
  }
  //Check server address with two bytes.
  if ((serverAddress & 0xFFFF0000) == 0 && (serverAddress & 0x7FFF) == 1)
  {
    return 1;
  }
  //Check server address with one byte.
  if ((serverAddress & 0xFFFFFF00) == 0 && (serverAddress & 0x7F) == 1)
  {
    return 1;
  }
  return 0;
}

DLMS_SOURCE_DIAGNOSTIC svr_validateAuthentication(
dlmsServerSettings* settings,
DLMS_AUTHENTICATION authentication,
gxByteBuffer* password)
{
  if (authentication == DLMS_AUTHENTICATION_NONE)
  {
    //Uncomment this if authentication is always required.
    //return DLMS_SOURCE_DIAGNOSTIC_AUTHENTICATION_MECHANISM_NAME_REQUIRED;
    return DLMS_SOURCE_DIAGNOSTIC_NONE;
  }
  //Uncomment this if only authentication None is supported.
  //return DLMS_SOURCE_DIAGNOSTIC_NO_REASON_GIVEN;
  return DLMS_SOURCE_DIAGNOSTIC_NONE;
}

/**
* Get attribute access level.
*/
DLMS_ACCESS_MODE svr_getAttributeAccess(
dlmsSettings *settings,
gxObject *obj,
unsigned char index)
{
  if (index == 1)
  {
    return DLMS_ACCESS_MODE_READ;
  }
  // Only read is allowed
  if (settings->authentication == DLMS_AUTHENTICATION_NONE)
  {
    return DLMS_ACCESS_MODE_READ;
  }
  // Only clock write is allowed.
  if (settings->authentication == DLMS_AUTHENTICATION_LOW)
  {
    if (obj->objectType == DLMS_OBJECT_TYPE_CLOCK)
    {
      return DLMS_ACCESS_MODE_READ_WRITE;
    }
    return DLMS_ACCESS_MODE_READ;
  }
  // All writes are allowed.
  return DLMS_ACCESS_MODE_READ_WRITE;
}

/**
* Get method access level.
*/
DLMS_METHOD_ACCESS_MODE svr_getMethodAccess(
dlmsSettings *settings,
gxObject *obj,
unsigned char index)
{
  // Methods are not allowed.
  if (settings->authentication == DLMS_AUTHENTICATION_NONE)
  {
    return DLMS_METHOD_ACCESS_MODE_NONE;
  }
  // Only clock methods are allowed.
  if (settings->authentication == DLMS_AUTHENTICATION_LOW)
  {
    if (obj->objectType == DLMS_OBJECT_TYPE_CLOCK)
    {
      return DLMS_METHOD_ACCESS_MODE_ACCESS;
    }
    return DLMS_METHOD_ACCESS_MODE_NONE;
  }
  return DLMS_METHOD_ACCESS_MODE_ACCESS;
}

/////////////////////////////////////////////////////////////////////////////
//Client has made connection to the server.
/////////////////////////////////////////////////////////////////////////////
int svr_connected(
  dlmsServerSettings *settings)
{
  return 0;
}

/**
* Client has try to made invalid connection. Password is incorrect.
*
* @param connectionInfo
*            Connection information.
*/
int svr_invalidConnection(
  dlmsServerSettings *settings)
{
  return 0;
}

/////////////////////////////////////////////////////////////////////////////
// Client has close the connection.
/////////////////////////////////////////////////////////////////////////////
int svr_disconnected(
  dlmsServerSettings *settings)
{
  return 0;
}

void svr_preGet(
dlmsSettings* settings,
gxValueEventCollection* args)
{
  gxValueEventArg *e;
  int ret, pos;
  for (pos = 0; pos != args->size; ++pos)
  {
    if ((ret = vec_getByIndex(args, pos, &e)) != 0)
    {
      return;
    }
  }
}

void svr_postGet(
dlmsSettings* settings,
gxValueEventCollection* args)
{

}

/**
* This is reserved for future use. Do not use it.
*
* @param args
*            Handled data type requests.
*/
void svr_getDataType(
dlmsSettings* settings,
gxValueEventCollection* args)
{
}

void UART3_IRQHandler (void)
{
  uint8_t IIRValue, LSRValue;
  uint8_t Dummy = Dummy;

  IIRValue = LPC_UART3->IIR;

  IIRValue >>= 1;			/* skip pending bit in IIR */
  IIRValue &= 0x07;			/* check bit 1~3, interrupt identification */
  if ( IIRValue == IIR_RLS )		/* Receive Line Status */
  {
	LSRValue = LPC_UART3->LSR;
	/* Receive Line Status */
	if ( LSRValue & (LSR_OE|LSR_PE|LSR_FE|LSR_RXFE|LSR_BI) )
	{
	  /* There are errors or break interrupt */
	  /* Read LSR will clear the interrupt */
	  UART3Status = LSRValue;
	  Dummy = LPC_UART3->RBR;		/* Dummy read on RX to clear
							interrupt, then bail out */
	  return;
	}
	if ( LSRValue & LSR_RDR )	/* Receive Data Ready */
	{
	  /* If no error on RLS, normal ready, save into the data buffer. */
	  /* Note: read RBR will clear the interrupt */
	  //UART3Buffer[UART3Count] = LPC_UART3->RBR;
	  //UART3Count++;
	  //if ( UART3Count == BUFSIZE )
	  //{
		//UART3Count = 0;		/* buffer overflow */
	  //}
		/* Receive Data Available */
		uint8_t ch = (uint8_t) LPC_UART3->RBR;

		UART3Buffer[UART3Count] = ch;
		UART3Count++;
		if ( UART3Count == BUFSIZE )
		{
				UART3Count = 0;		/* buffer overflow */
		}

		if (svr_handleRequest3(&settings, (unsigned char)ch, &reply) != 0)
		{
			bb_clear(&reply);
		}

		if (reply.size != 0)
		{
			  //Send reply.
		  //for (size_t i = 0; i < reply.size; i++) {
		   //uart_poll_out(uart_dev, reply.data[i]);
			sendReply = 1;
		}

	}
  }
  else if ( IIRValue == IIR_RDA )	/* Receive Data Available */
  {
	/* Receive Data Available */
	uint8_t ch = (uint8_t) LPC_UART3->RBR;

	 UART3Buffer[UART3Count] = ch;
	 UART3Count++;
		  if ( UART3Count == BUFSIZE )
		  {
			UART3Count = 0;		/* buffer overflow */
		  }
		  if (svr_handleRequest3(&settings, (unsigned char)ch, &reply) != 0)
		  {
			  bb_clear(&reply);
		  }

		  if (reply.size != 0)
		  {
			  	  //Send reply.
			  //for (size_t i = 0; i < reply.size; i++) {
			//uart_poll_out(uart_dev, reply.data[i]);
			  sendReply = 1;
		  }


  }
  else if ( IIRValue == IIR_CTI )	/* Character timeout indicator */
  {
	/* Character Time-out indicator */
	UART3Status |= 0x100;		/* Bit 9 as the CTI error */
  }
  else if ( IIRValue == IIR_THRE )	/* THRE, transmit holding register empty */
  {
	/* THRE interrupt */
	LSRValue = LPC_UART3->LSR;		/* Check status in the LSR to see if
									valid data in U0THR or not */
	if ( LSRValue & LSR_THRE )
	{
	  UART3TxEmpty = 1;
	}
	else
	{
	  UART3TxEmpty = 0;
	}
  }
}



#if 0
static void isr(struct device *x)
{

  uart_irq_update(x);
  if (uart_irq_rx_ready(x)) {
    char ch;
    int ret = uart_fifo_read(x, &ch, 1);
    if (ret != 0)
    {
      if (svr_handleRequest3(&settings, ch, &reply) != 0)
      {
       bb_clear(&reply);
      }
      if (reply.size != 0)
      {
        //Send reply.
        for (size_t i = 0; i < reply.size; i++) {
          uart_poll_out(uart_dev, reply.data[i]);
        }
        bb_clear(&reply);
      }
    }
  }

}

static int gx_uart_init(char *uart_dev_name)
{
  int err;
  uart_dev = device_get_binding(uart_dev_name);
  if (uart_dev == NULL) {
    printf("Cannot bind %s\n", uart_dev_name);
    return EINVAL;
  }
  err = uart_err_check(uart_dev);
  if (err) {
    printf("UART check failed\n");
    return EINVAL;
  }
  uart_irq_rx_enable(uart_dev);
  uart_irq_callback_set(uart_dev, isr);
  return err;
}
#endif

////////////////////////////////////////************************************************//////////////////
void delay_ms(unsigned int ms)
{
    unsigned int i,j;

    for(i=0;i<ms;i++)
        for(j=0;j<20000;j++);
}

////////////////////////////////////////********************************************//////////////////////////


int main(void)
{
#if 1
  int ret;

  //SysTick_Config(12000);  /* 0.1 ms = 100us if clock frequency 120 MHz */
  //init_systick();
  //started = _impl_k_uptime_get();
  characters = 0;
	
 //// Led Blink////
  SystemInit();                    //Clock and PLL configuration
  LPC_PINCON->PINSEL4 =0x00 ;  //Configure the PORT2 Pins as GPIO;
  LPC_GPIO2->FIODIR = 0xffffffff;  //Configure the PORT2 pins as OUTPUT;

  LPC_GPIO2->FIOSET = 0xffffffff;     // Make all the Port pins as high
  //delay_ms(100);

  LPC_GPIO2->FIOCLR = 0xffffffff;     // Make all the Port pins as low
 // delay_ms(100);
////// Led Blink///

	
// Reply structure Initialize 	
  bb_init(&reply);
  //energy_meter_init();	//rakesh
  // Here pdu is given
  //Start server using logical name referencing and HDLC framing.
  svr_init(&settings, 1, DLMS_INTERFACE_TYPE_HDLC, HDLC_BUFFER_SIZE, PDU_BUFFER_SIZE, frame, HDLC_BUFFER_SIZE, pdu, PDU_BUFFER_SIZE);
  //Add COSEM objects.
  svr_InitObjects(&settings);
  //Start server
  if ((ret = svr_initialize(&settings)) != 0)
  {
    printf("svr_initialize failed.\r\n");
    return -1;
  }
  printf("Gurux DLMS sample started.\n");

  /* Infinite loop */
  UARTInit(3, 9600);
  energy_meter_init();

  //

  while (true) {
	  if(sendReply)
	  {
		  UARTSend(3, reply.data, reply.size);
		  		//}
		  bb_clear(&reply);
		  sendReply = 0;
	  }
  }

#else
  energy_meter_init();

  readVoltage(VR_REG);	//11804	0.01
  readVoltage(VY_REG);
  readVoltage(VB_REG);
  readCurrent(CR_REG);
  readCurrent(CY_REG);
  readCurrent(CB_REG);
  readActPower(ACT_POW_R_REG);
  readActPower(ACT_POW_Y_REG);
  readActPower(ACT_POW_B_REG);
  readReActPower(REACT_POW_R_REG);
  readReActPower(REACT_POW_Y_REG);
  readReActPower(REACT_POW_B_REG);
  readAppaPower(APPA_POW_R_REG);
  readAppaPower(APPA_POW_Y_REG);
  readAppaPower(APPA_POW_B_REG);
  readPowerFactor(POW_FACT_R_REG);		//42000 	0.1000
  readPowerFactor(POW_FACT_Y_REG);
  readPowerFactor(POW_FACT_B_REG);
  readTotalActivePower();
  readTotalApparentPower();
  readTotalPowerFactor();				//42000		0.1000
  readLineFrequency();					//5006		0.01
  readPhaseSequence();


  //Cumulative Energies .....all the tested commands .....results will show in display 3
  read(F_Wh);	//Forward Active energy            getting 1925    showing 92.5
  read(F_VArh_lag);	//Forward Reactive energy -lag
  read(F_VArh_lead); //Forward Reactive energy -lead
  read(F_VAhs); //Forward Apparent energy           getting 2562    showing 56.2
  read(R_Wh);	//Reverse Active energy
  read(R_VArh_lag); //Reverse Reactive energy -lag
  read(R_VArh_lead); //Reverse Reactive energy -lead
  read(R_Vah); //Reverse Apparent energy			getting 1187     showing 18.7
#endif

}


